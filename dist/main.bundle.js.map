{"version":3,"file":"main.bundle.js","mappings":"mBAAO,MAcMA,EAAU,KAAU,O,OAAA,E,OAAA,E,EAAA,YAC7B,MAAMC,EAAWC,IACjB,GAAGD,EAASE,SAAS,sBAEjB,MADAC,QAAQC,IAAIJ,GACP,qBAET,MAAMK,EAASC,SAASC,cAAc,kBAEhCC,QAAgBC,UAAUC,IAAIC,iBACpC,IAAIC,QAAeJ,MAAAA,OAAO,EAAPA,EAASK,gBAE5BD,EAAOE,KAAKC,MAAMC,IACdb,QAAQc,MAAM,2BAA2BD,EAAKE,WAE9CN,EAAS,KAOU,aAAfI,EAAKG,QACLpB,OAIR,MAAMqB,EAAUf,EAAOgB,WAAW,UAE5BC,EAAmBC,OAAOD,kBAAoB,EAC9CE,EAAmB,CACrBnB,EAAOoB,YAAcH,EACrBjB,EAAOqB,aAAeJ,GAEpBK,EAAqBP,EAAQQ,mBAAmBpB,GAStD,OANAY,EAAQS,UAAU,CACdjB,OAAAA,EACAkB,OAAQH,EACRI,KAAMP,IAGH,CAACZ,OAAAA,EAAQP,OAAAA,EAAQe,QAAAA,EAASO,mBAAAA,I,YA1CJ,K,+QA6CpB1B,EAAc,KACvB,IAAI+B,EAAS,+CAUb,OATSvB,UAAUC,MACZsB,EAAS,4hBAQTA,GCnEX,IAAIC,EAAgB,K,UAEW,YACxB,MAAM,OAACrB,EAAM,QAAEQ,EAAO,mBAAEO,SAA4B5B,IAE9CmC,EAAa,IAAIC,aAAa,EAEjC,IAAM,GAAO,EAAG,EAAG,EACpB,IAAM,GAAQ,EAAG,EAAG,GACnB,GAAK,GAAQ,EAAG,EAAG,GACnB,GAAK,GAAQ,EAAG,EAAG,EACpB,IAAM,GAAQ,EAAG,EAAG,EACpB,GAAK,GAAS,EAAG,EAAG,IAGjBC,EDlBmB,EAACxB,EAAkByB,EAC9CC,EAAgCC,eAAeC,OAASD,eAAeE,YACvE,MAAMC,EAAS9B,EAAO+B,aAAa,CAC/BZ,KAAKM,EAAKO,WACVC,MAAMP,EACNQ,kBAAiB,IAMrB,OAHA,IAAIX,aAAaO,EAAOK,kBAAkBC,IAAIX,GAE9CK,EAAOO,QACAP,GCOgBQ,CAAgBtC,EAAQsB,GAEvCiB,ECnBO,8eDmBPA,ECHS,sKDITC,EAAWxC,EAAOyC,qBAAqB,CAC3CC,OAAQ,CACNC,OAAQ3C,EAAO4C,mBAAmB,CAChCC,KAAMN,IAERO,WAAY,OACZC,QAAQ,CACN,CACEC,YAAa,GACbC,WAAW,CAAC,CACVC,eAAe,EACfhC,OAAO,YACPiC,OAAO,GAET,CACED,eAAe,EACfhC,OAAO,YACPiC,OAAO,OAKfC,SAAU,CACRT,OAAQ3C,EAAO4C,mBAAmB,CAChCC,KAAMN,IAERO,WAAY,OACZO,QAAS,CACP,CACEnC,OAAQH,KAIduC,UAAW,CACTC,SAAU,mBA+BdlC,EAAYmC,uBA3BZ,WAGE,MAAMC,EAAiBzD,EAAO0D,uBAGxBC,EAAgD,CACpDC,iBAAkB,CAChB,CACEC,KALcrD,EAAQsD,oBAAoBC,aAM1CC,UAAW,CAAEC,EAAG,GAAKC,EAAG,GAAKC,EAAG,GAAKC,EAAG,GACxCC,QAAS,WAKTC,EAAcb,EAAec,gBAAgBZ,GACnDW,EAAYE,YAAYhC,GACxB8B,EAAYG,gBAAgB,EAAGjD,GAE/B8C,EAAYI,KAAK,GACjBJ,EAAYK,UAEZ3E,EAAO4E,MAAMC,OAAO,CAACpB,EAAeqB,e,YA7Eb,K,kPAAA,E","sources":["webpack://webgpu01/./src/helper.ts","webpack://webgpu01/./src/main.ts","webpack://webgpu01/./src/shader.ts"],"sourcesContent":["export const CreateGPUBuffer = (device:GPUDevice, data:Float32Array,\n    usageFlag:GPUBufferUsageFlags = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST)=>{\n    const buffer = device.createBuffer({\n        size:data.byteLength,\n        usage:usageFlag,\n        mappedAtCreation:true   // 设置为true 可以通过getMappedRange 获取GPU中的缓存\n    })\n\n    new Float32Array(buffer.getMappedRange()).set(data)\n    // 更改为unmap状态 GPU才可以使用\n    buffer.unmap()\n    return buffer\n}\n\nexport const InitGPU = async ()=>{\n    const checkGPU = CheckWebGPU()\n    if(checkGPU.includes('not support WebGPU')){\n        console.log(checkGPU)\n        throw('not support WebGPU')\n    }\n    const canvas = document.querySelector('#canvas-webgpu') as HTMLCanvasElement;\n    \n    const adapter = await navigator.gpu.requestAdapter() as GPUAdapter\n    let device = await adapter?.requestDevice() as GPUDevice\n\n    device.lost.then((info) => {\n        console.error(`WebGPU device was lost: ${info.message}`);\n        // @ts-ignore\n        device = null;\n\n        // Many causes for lost devices are transient, so applications should try getting a\n        // new device once a previous one has been lost unless the loss was caused by the\n        // application intentionally destroying the device. Note that any WebGPU resources\n        // created with the previous device (buffers, textures, etc) will need to be\n        // re-created with the new one.\n        if (info.reason != 'destroyed') {\n            InitGPU();\n        }\n    });\n    \n    const context = canvas.getContext('webgpu')as unknown  as GPUCanvasContext\n  \n    const devicePixelRatio = window.devicePixelRatio || 1;\n    const presentationSize = [\n        canvas.clientWidth * devicePixelRatio,\n        canvas.clientHeight * devicePixelRatio,\n    ];\n    const presentationFormat = context.getPreferredFormat(adapter);\n\n    \n    context.configure({\n        device,\n        format: presentationFormat,\n        size: presentationSize,\n      });\n\n    return {device, canvas, context, presentationFormat}\n}\n\nexport const CheckWebGPU = () => {\n    let result = 'Great, your current browser supports WebGPU!';\n        if (!navigator.gpu) {\n           result = `Your current browser does not support WebGPU! Make sure you are on a system \n                     with WebGPU enabled. Currently, SPIR-WebGPU is only supported in  \n                     <a href=\"https://www.google.com/chrome/canary/\">Chrome canary</a>\n                     with the flag \"enable-unsafe-webgpu\" enabled. See the \n                     <a href=\"https://github.com/gpuweb/gpuweb/wiki/Implementation-Status\"> \n                     Implementation Status</a> page for more details.                   \n                    `;\n        } \n    return result;\n}","import { InitGPU,CreateGPUBuffer } from './helper';\nimport { Shaders } from './shader';\n\nlet requestId:any = null\n\nconst CreateSquare = async ()=>{\n       const {device, context, presentationFormat} = await InitGPU()\n\n       const vertexData = new Float32Array([\n         // position      color\n         -0.5, -0.5,   1, 0, 0,    // a red \n         0.5, -0.5,    0, 1, 0,    // b green\n         -0.5, 0.5,    1, 1, 0,    // d yellow \n         -0.5, 0.5,    1, 1, 0,    // d yellow \n         0.5, -0.5,    0, 1, 0,    // b green \n         0.5, 0.5,     0, 0, 1     // c blue \n       ])\n\n      const vertexBuffer = CreateGPUBuffer(device, vertexData)\n\n      const shader = Shaders();\n      const pipeline = device.createRenderPipeline({\n        vertex: {\n          module: device.createShaderModule({\n            code: shader.vertex,\n          }),\n          entryPoint: 'main',\n          buffers:[\n            {\n              arrayStride: 4*(2+3),\n              attributes:[{\n                shaderLocation:0,\n                format:\"float32x2\",\n                offset:0\n              },\n              {\n                shaderLocation:1,\n                format:\"float32x3\",\n                offset:8\n              }]\n            },\n          ]\n        },\n        fragment: {\n          module: device.createShaderModule({\n            code: shader.fragment,\n          }),\n          entryPoint: 'main',\n          targets: [\n            {\n              format: presentationFormat,\n            },\n          ],\n        },\n        primitive: {\n          topology: 'triangle-list',\n        },\n      });\n      // if(requestId!==null) cancelAnimationFrame(requestId)\n      function frame() {\n        // Sample is no longer the active page.\n    \n        const commandEncoder = device.createCommandEncoder();\n        const textureView = context.getCurrentTexture().createView();\n    \n        const renderPassDescriptor: GPURenderPassDescriptor = {\n          colorAttachments: [\n            {\n              view: textureView,\n              loadValue: { r: 0.5, g: 0.5, b: 0.8, a: 1.0 },\n              storeOp: 'store',  // 储存模式\n            },\n          ],\n        };\n    \n        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n        passEncoder.setPipeline(pipeline)\n        passEncoder.setVertexBuffer(0, vertexBuffer)\n\n        passEncoder.draw(6)\n        passEncoder.endPass();\n    \n        device.queue.submit([commandEncoder.finish()]);\n        // requestId =  requestAnimationFrame(frame);\n      }\n    \n      requestId = requestAnimationFrame(frame);\n    \n}\n\n\nCreateSquare()\n","export const Shaders = ()=>{\n    const vertex = `\n            struct VertexOutput {\n                @builtin(position) Position : vec4<f32>;\n                @location(1) vColor: vec4<f32>;\n            };\n\n            @stage(vertex)\n            fn main(@location(0) pos:vec4<f32>,\n                    @location(1) color:vec4<f32>) -> VertexOutput{   \n                var output : VertexOutput;      \n                output.Position = pos;\n                output.vColor = color;\n                return output;\n            }\n    `;\n\n    const fragment = `\n            @stage(fragment)\n            fn main(@location(1) vColor: vec4<f32>) -> @location(0) vec4<f32>{\n                return vColor;\n            }\n    `;\n    return {vertex, fragment}\n}"],"names":["InitGPU","checkGPU","CheckWebGPU","includes","console","log","canvas","document","querySelector","adapter","navigator","gpu","requestAdapter","device","requestDevice","lost","then","info","error","message","reason","context","getContext","devicePixelRatio","window","presentationSize","clientWidth","clientHeight","presentationFormat","getPreferredFormat","configure","format","size","result","requestId","vertexData","Float32Array","vertexBuffer","data","usageFlag","GPUBufferUsage","VERTEX","COPY_DST","buffer","createBuffer","byteLength","usage","mappedAtCreation","getMappedRange","set","unmap","CreateGPUBuffer","shader","pipeline","createRenderPipeline","vertex","module","createShaderModule","code","entryPoint","buffers","arrayStride","attributes","shaderLocation","offset","fragment","targets","primitive","topology","requestAnimationFrame","commandEncoder","createCommandEncoder","renderPassDescriptor","colorAttachments","view","getCurrentTexture","createView","loadValue","r","g","b","a","storeOp","passEncoder","beginRenderPass","setPipeline","setVertexBuffer","draw","endPass","queue","submit","finish"],"sourceRoot":""}