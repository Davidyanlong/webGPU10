{"version":3,"file":"main.bundle.js","mappings":"mBAAO,MAAMA,EAAkB,CAACC,EAAkBC,EAC9CC,EAAgCC,eAAeC,OAASD,eAAeE,YACvE,MAAMC,EAASN,EAAOO,aAAa,CAC/BC,KAAKP,EAAKQ,WACVC,MAAMR,EACNS,kBAAiB,IAMrB,OAHA,IAAIC,aAAaN,EAAOO,kBAAkBC,IAAIb,GAE9CK,EAAOS,QACAT,GAGEU,EAAU,KAAU,O,OAAA,E,OAAA,E,EAAA,YAC7B,MAAMC,EAAWC,IACjB,GAAGD,EAASE,SAAS,sBAEjB,MADAC,QAAQC,IAAIJ,GACP,qBAET,MAAMK,EAASC,SAASC,cAAc,kBAEhCC,QAAgBC,UAAUC,IAAIC,iBACpC,IAAI5B,QAAeyB,MAAAA,OAAO,EAAPA,EAASI,gBAE5B7B,EAAO8B,KAAKC,MAAMC,IACdZ,QAAQa,MAAM,2BAA2BD,EAAKE,WAE9ClC,EAAS,KAOU,aAAfgC,EAAKG,QACLnB,OAIR,MAAMoB,EAAUd,EAAOe,WAAW,UAE5BC,EAAmBC,OAAOD,kBAAoB,EAC9CE,EAAmB,CACrBlB,EAAOmB,YAAcH,EACrBhB,EAAOoB,aAAeJ,GAEpBK,EAAqBP,EAAQQ,mBAAmBnB,GAStD,OANAW,EAAQS,UAAU,CACd7C,OAAAA,EACA8C,OAAQH,EACRnC,KAAMgC,IAGH,CAACxC,OAAAA,EAAQsB,OAAAA,EAAQc,QAAAA,EAASO,mBAAAA,I,YA1CJ,K,+QA6CpBzB,EAAc,KACvB,IAAI6B,EAAS,+CAUb,OATSrB,UAAUC,MACZoB,EAAS,4hBAQTA,GCnEX,IAAIC,EAAgB,K,UAEW,YACxB,MAAM,OAAChD,EAAM,QAAEoC,EAAO,mBAAEO,SAA4B3B,IAE9CiC,EAAa,IAAIrC,aAAa,EACjC,IAAM,GACP,IAAM,IACL,GAAK,IACL,GAAK,GACN,IAAM,GACN,GAAK,KAGDsC,EAAY,IAAItC,aAAa,CACjC,EAAG,EAAG,EACN,EAAG,EAAG,EACN,EAAG,EAAG,EACN,EAAG,EAAG,EACN,EAAG,EAAG,EACN,EAAG,EAAG,IAGHuC,EAAepD,EAAgBC,EAAQiD,GACvCG,EAAcrD,EAAgBC,EAAQkD,GAEtCG,EC5BO,8eD4BPA,ECZS,sKDaTC,EAAWtD,EAAOuD,qBAAqB,CAC3CC,OAAQ,CACNC,OAAQzD,EAAO0D,mBAAmB,CAChCC,KAAMN,IAERO,WAAY,OACZC,QAAQ,CACN,CACEC,YAAY,EACZC,WAAW,CAAC,CACVC,eAAe,EACflB,OAAO,YACPmB,OAAO,KAGX,CACEH,YAAY,GACZC,WAAW,CAAC,CACVC,eAAe,EACflB,OAAO,YACPmB,OAAO,OAKfC,SAAU,CACRT,OAAQzD,EAAO0D,mBAAmB,CAChCC,KAAMN,IAERO,WAAY,OACZO,QAAS,CACP,CACErB,OAAQH,KAIdyB,UAAW,CACTC,SAAU,mBAgCdrB,EAAYsB,uBA5BZ,WAGE,MAAMC,EAAiBvE,EAAOwE,uBAGxBC,EAAgD,CACpDC,iBAAkB,CAChB,CACEC,KALcvC,EAAQwC,oBAAoBC,aAM1CC,UAAW,CAAEC,EAAG,GAAKC,EAAG,GAAKC,EAAG,GAAKC,EAAG,GACxCC,QAAS,WAKTC,EAAcb,EAAec,gBAAgBZ,GACnDW,EAAYE,YAAYhC,GACxB8B,EAAYG,gBAAgB,EAAGpC,GAC/BiC,EAAYG,gBAAgB,EAAGnC,GAE/BgC,EAAYI,KAAK,GACjBJ,EAAYK,UAEZzF,EAAO0F,MAAMC,OAAO,CAACpB,EAAeqB,e,YA1Fb,K,kPAAA,E","sources":["webpack://webgpu01/./src/helper.ts","webpack://webgpu01/./src/main.ts","webpack://webgpu01/./src/shader.ts"],"sourcesContent":["export const CreateGPUBuffer = (device:GPUDevice, data:Float32Array,\n    usageFlag:GPUBufferUsageFlags = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST)=>{\n    const buffer = device.createBuffer({\n        size:data.byteLength,\n        usage:usageFlag,\n        mappedAtCreation:true   // 设置为true 可以通过getMappedRange 获取GPU中的缓存\n    })\n\n    new Float32Array(buffer.getMappedRange()).set(data)\n    // 更改为unmap状态 GPU才可以使用\n    buffer.unmap()\n    return buffer\n}\n\nexport const InitGPU = async ()=>{\n    const checkGPU = CheckWebGPU()\n    if(checkGPU.includes('not support WebGPU')){\n        console.log(checkGPU)\n        throw('not support WebGPU')\n    }\n    const canvas = document.querySelector('#canvas-webgpu') as HTMLCanvasElement;\n    \n    const adapter = await navigator.gpu.requestAdapter() as GPUAdapter\n    let device = await adapter?.requestDevice() as GPUDevice\n\n    device.lost.then((info) => {\n        console.error(`WebGPU device was lost: ${info.message}`);\n        // @ts-ignore\n        device = null;\n\n        // Many causes for lost devices are transient, so applications should try getting a\n        // new device once a previous one has been lost unless the loss was caused by the\n        // application intentionally destroying the device. Note that any WebGPU resources\n        // created with the previous device (buffers, textures, etc) will need to be\n        // re-created with the new one.\n        if (info.reason != 'destroyed') {\n            InitGPU();\n        }\n    });\n    \n    const context = canvas.getContext('webgpu')as unknown  as GPUCanvasContext\n  \n    const devicePixelRatio = window.devicePixelRatio || 1;\n    const presentationSize = [\n        canvas.clientWidth * devicePixelRatio,\n        canvas.clientHeight * devicePixelRatio,\n    ];\n    const presentationFormat = context.getPreferredFormat(adapter);\n\n    \n    context.configure({\n        device,\n        format: presentationFormat,\n        size: presentationSize,\n      });\n\n    return {device, canvas, context, presentationFormat}\n}\n\nexport const CheckWebGPU = () => {\n    let result = 'Great, your current browser supports WebGPU!';\n        if (!navigator.gpu) {\n           result = `Your current browser does not support WebGPU! Make sure you are on a system \n                     with WebGPU enabled. Currently, SPIR-WebGPU is only supported in  \n                     <a href=\"https://www.google.com/chrome/canary/\">Chrome canary</a>\n                     with the flag \"enable-unsafe-webgpu\" enabled. See the \n                     <a href=\"https://github.com/gpuweb/gpuweb/wiki/Implementation-Status\"> \n                     Implementation Status</a> page for more details.                   \n                    `;\n        } \n    return result;\n}","import { InitGPU,CreateGPUBuffer } from './helper';\nimport { Shaders } from './shader';\n\nlet requestId:any = null\n\nconst CreateSquare = async ()=>{\n       const {device, context, presentationFormat} = await InitGPU()\n\n       const vertexData = new Float32Array([\n         -0.5, -0.5,    // a\n         0.5, -0.5,     // b\n         -0.5, 0.5,     // d\n         -0.5, 0.5,     // d\n         0.5, -0.5,     // b\n         0.5, 0.5,      // c\n       ])\n\n       const colorData = new Float32Array([\n         1, 0, 0,    // a red\n         0, 1, 0,    // b green\n         1, 1, 0,    // d yellow\n         1, 1, 0,    // d yellow\n         0, 1, 0,    // b green\n         0, 0, 1     // c blue\n       ])\n\n      const vertexBuffer = CreateGPUBuffer(device, vertexData)\n      const colorBuffer = CreateGPUBuffer(device, colorData)\n\n      const shader = Shaders();\n      const pipeline = device.createRenderPipeline({\n        vertex: {\n          module: device.createShaderModule({\n            code: shader.vertex,\n          }),\n          entryPoint: 'main',\n          buffers:[\n            {\n              arrayStride:8,\n              attributes:[{\n                shaderLocation:0,\n                format:\"float32x2\",\n                offset:0\n              }]\n            },\n            {\n              arrayStride:12,\n              attributes:[{\n                shaderLocation:1,\n                format:\"float32x3\",\n                offset:0\n              }]\n            },\n          ]\n        },\n        fragment: {\n          module: device.createShaderModule({\n            code: shader.fragment,\n          }),\n          entryPoint: 'main',\n          targets: [\n            {\n              format: presentationFormat,\n            },\n          ],\n        },\n        primitive: {\n          topology: 'triangle-list',\n        },\n      });\n      // if(requestId!==null) cancelAnimationFrame(requestId)\n      function frame() {\n        // Sample is no longer the active page.\n    \n        const commandEncoder = device.createCommandEncoder();\n        const textureView = context.getCurrentTexture().createView();\n    \n        const renderPassDescriptor: GPURenderPassDescriptor = {\n          colorAttachments: [\n            {\n              view: textureView,\n              loadValue: { r: 0.5, g: 0.5, b: 0.8, a: 1.0 },\n              storeOp: 'store',  // 储存模式\n            },\n          ],\n        };\n    \n        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n        passEncoder.setPipeline(pipeline)\n        passEncoder.setVertexBuffer(0, vertexBuffer)\n        passEncoder.setVertexBuffer(1, colorBuffer)\n\n        passEncoder.draw(6)\n        passEncoder.endPass();\n    \n        device.queue.submit([commandEncoder.finish()]);\n        // requestId =  requestAnimationFrame(frame);\n      }\n    \n      requestId = requestAnimationFrame(frame);\n    \n}\n\n\nCreateSquare()\n","export const Shaders = ()=>{\n    const vertex = `\n            struct VertexOutput {\n                @builtin(position) Position : vec4<f32>;\n                @location(1) vColor: vec4<f32>;\n            };\n\n            @stage(vertex)\n            fn main(@location(0) pos:vec4<f32>,\n                    @location(1) color:vec4<f32>) -> VertexOutput{   \n                var output : VertexOutput;      \n                output.Position = pos;\n                output.vColor = color;\n                return output;\n            }\n    `;\n\n    const fragment = `\n            @stage(fragment)\n            fn main(@location(1) vColor: vec4<f32>) -> @location(0) vec4<f32>{\n                return vColor;\n            }\n    `;\n    return {vertex, fragment}\n}"],"names":["CreateGPUBuffer","device","data","usageFlag","GPUBufferUsage","VERTEX","COPY_DST","buffer","createBuffer","size","byteLength","usage","mappedAtCreation","Float32Array","getMappedRange","set","unmap","InitGPU","checkGPU","CheckWebGPU","includes","console","log","canvas","document","querySelector","adapter","navigator","gpu","requestAdapter","requestDevice","lost","then","info","error","message","reason","context","getContext","devicePixelRatio","window","presentationSize","clientWidth","clientHeight","presentationFormat","getPreferredFormat","configure","format","result","requestId","vertexData","colorData","vertexBuffer","colorBuffer","shader","pipeline","createRenderPipeline","vertex","module","createShaderModule","code","entryPoint","buffers","arrayStride","attributes","shaderLocation","offset","fragment","targets","primitive","topology","requestAnimationFrame","commandEncoder","createCommandEncoder","renderPassDescriptor","colorAttachments","view","getCurrentTexture","createView","loadValue","r","g","b","a","storeOp","passEncoder","beginRenderPass","setPipeline","setVertexBuffer","draw","endPass","queue","submit","finish"],"sourceRoot":""}