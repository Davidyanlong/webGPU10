{"version":3,"file":"main.bundle.js","mappings":"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","sources":["webpack://webgpu01/./src/helper.ts","webpack://webgpu01/./src/main.ts","webpack://webgpu01/./src/shader.ts"],"sourcesContent":["export const CreateGPUBufferUnit = (device:GPUDevice, data:Uint32Array,\n    usageFlag:GPUBufferUsageFlags = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST)=>{\n    const buffer = device.createBuffer({\n        size:data.byteLength,\n        usage:usageFlag,\n        mappedAtCreation:true   // 设置为true 可以通过getMappedRange 获取GPU中的缓存\n    })\n\n    new Uint32Array(buffer.getMappedRange()).set(data)\n    // 更改为unmap状态 GPU才可以使用\n    buffer.unmap()\n    return buffer\n}\n\nexport const CreateGPUBuffer = (device:GPUDevice, data:Float32Array,\n    usageFlag:GPUBufferUsageFlags = GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST)=>{\n    const buffer = device.createBuffer({\n        size:data.byteLength,\n        usage:usageFlag,\n        mappedAtCreation:true   // 设置为true 可以通过getMappedRange 获取GPU中的缓存\n    })\n\n    new Float32Array(buffer.getMappedRange()).set(data)\n    // 更改为unmap状态 GPU才可以使用\n    buffer.unmap()\n    return buffer\n}\n\nexport const InitGPU = async ()=>{\n    const checkGPU = CheckWebGPU()\n    if(checkGPU.includes('not support WebGPU')){\n        console.log(checkGPU)\n        throw('not support WebGPU')\n    }\n    const canvas = document.querySelector('#canvas-webgpu') as HTMLCanvasElement;\n    \n    const adapter = await navigator.gpu.requestAdapter() as GPUAdapter\n    let device = await adapter?.requestDevice() as GPUDevice\n\n    device.lost.then((info) => {\n        console.error(`WebGPU device was lost: ${info.message}`);\n        // @ts-ignore\n        device = null;\n\n        // Many causes for lost devices are transient, so applications should try getting a\n        // new device once a previous one has been lost unless the loss was caused by the\n        // application intentionally destroying the device. Note that any WebGPU resources\n        // created with the previous device (buffers, textures, etc) will need to be\n        // re-created with the new one.\n        if (info.reason != 'destroyed') {\n            InitGPU();\n        }\n    });\n    \n    const context = canvas.getContext('webgpu')as unknown  as GPUCanvasContext\n  \n    const devicePixelRatio = window.devicePixelRatio || 1;\n    const presentationSize = [\n        canvas.clientWidth * devicePixelRatio,\n        canvas.clientHeight * devicePixelRatio,\n    ];\n    const presentationFormat = context.getPreferredFormat(adapter);\n\n    \n    context.configure({\n        device,\n        format: presentationFormat,\n        size: presentationSize,\n      });\n\n    return {device, canvas, context, presentationFormat}\n}\n\nexport const CheckWebGPU = () => {\n    let result = 'Great, your current browser supports WebGPU!';\n        if (!navigator.gpu) {\n           result = `Your current browser does not support WebGPU! Make sure you are on a system \n                     with WebGPU enabled. Currently, SPIR-WebGPU is only supported in  \n                     <a href=\"https://www.google.com/chrome/canary/\">Chrome canary</a>\n                     with the flag \"enable-unsafe-webgpu\" enabled. See the \n                     <a href=\"https://github.com/gpuweb/gpuweb/wiki/Implementation-Status\"> \n                     Implementation Status</a> page for more details.                   \n                    `;\n        } \n    return result;\n}","import { InitGPU,CreateGPUBuffer,CreateGPUBufferUnit } from './helper';\nimport { Shaders } from './shader';\n\nlet requestId:any = null\n\nconst CreateSquare = async ()=>{\n       const {device, context, presentationFormat} = await InitGPU()\n\n       const vertexData = new Float32Array([\n         // position      color\n         -0.5, -0.5,   1, 0, 0,    // a red    0\n         0.5, -0.5,    0, 1, 0,    // b green  1\n         0.5, 0.5,     0, 0, 1,    // c blue   2\n         -0.5, 0.5,    1, 1, 0,    // d yellow 3        \n       ])\n\n       const indexData =new Uint32Array([\n         0, 1, 3,\n         3, 1, 2\n       ])\n\n      const vertexBuffer = CreateGPUBuffer(device, vertexData)\n      const indexBuffer = CreateGPUBufferUnit(device,indexData)\n      const shader = Shaders();\n      const pipeline = device.createRenderPipeline({\n        vertex: {\n          module: device.createShaderModule({\n            code: shader.vertex,\n          }),\n          entryPoint: 'main',\n          buffers:[\n            {\n              arrayStride: 4*(2+3),\n              attributes:[{\n                shaderLocation:0,\n                format:\"float32x2\",\n                offset:0\n              },\n              {\n                shaderLocation:1,\n                format:\"float32x3\",\n                offset:8\n              }]\n            },\n          ]\n        },\n        fragment: {\n          module: device.createShaderModule({\n            code: shader.fragment,\n          }),\n          entryPoint: 'main',\n          targets: [\n            {\n              format: presentationFormat,\n            },\n          ],\n        },\n        primitive: {\n          topology: 'triangle-list',\n        },\n      });\n      // if(requestId!==null) cancelAnimationFrame(requestId)\n      function frame() {\n        // Sample is no longer the active page.\n    \n        const commandEncoder = device.createCommandEncoder();\n        const textureView = context.getCurrentTexture().createView();\n    \n        const renderPassDescriptor: GPURenderPassDescriptor = {\n          colorAttachments: [\n            {\n              view: textureView,\n              loadValue: { r: 0.5, g: 0.5, b: 0.8, a: 1.0 },\n              storeOp: 'store',  // 储存模式\n            },\n          ],\n        };\n    \n        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n        passEncoder.setPipeline(pipeline)\n        passEncoder.setVertexBuffer(0, vertexBuffer)\n        passEncoder.setIndexBuffer(indexBuffer, \"uint32\")\n\n        passEncoder.drawIndexed(6)\n        passEncoder.endPass();\n    \n        device.queue.submit([commandEncoder.finish()]);\n        // requestId =  requestAnimationFrame(frame);\n      }\n    \n      requestId = requestAnimationFrame(frame);\n    \n}\n\n\nCreateSquare()\n","export const Shaders = ()=>{\n    const vertex = `\n            struct VertexOutput {\n                @builtin(position) Position : vec4<f32>;\n                @location(1) vColor: vec4<f32>;\n            };\n\n            @stage(vertex)\n            fn main(@location(0) pos:vec4<f32>,\n                    @location(1) color:vec4<f32>) -> VertexOutput{   \n                var output : VertexOutput;      \n                output.Position = pos;\n                output.vColor = color;\n                return output;\n            }\n    `;\n\n    const fragment = `\n            @stage(fragment)\n            fn main(@location(1) vColor: vec4<f32>) -> @location(0) vec4<f32>{\n                return vColor;\n            }\n    `;\n    return {vertex, fragment}\n}"],"names":["InitGPU","checkGPU","CheckWebGPU","includes","console","log","canvas","document","querySelector","adapter","navigator","gpu","requestAdapter","device","requestDevice","lost","then","info","error","message","reason","context","getContext","devicePixelRatio","window","presentationSize","clientWidth","clientHeight","presentationFormat","getPreferredFormat","configure","format","size","result","requestId","vertexData","Float32Array","indexData","Uint32Array","vertexBuffer","data","usageFlag","GPUBufferUsage","VERTEX","COPY_DST","buffer","createBuffer","byteLength","usage","mappedAtCreation","getMappedRange","set","unmap","CreateGPUBuffer","indexBuffer","INDEX","CreateGPUBufferUnit","shader","pipeline","createRenderPipeline","vertex","module","createShaderModule","code","entryPoint","buffers","arrayStride","attributes","shaderLocation","offset","fragment","targets","primitive","topology","requestAnimationFrame","commandEncoder","createCommandEncoder","renderPassDescriptor","colorAttachments","view","getCurrentTexture","createView","loadValue","r","g","b","a","storeOp","passEncoder","beginRenderPass","setPipeline","setVertexBuffer","setIndexBuffer","drawIndexed","endPass","queue","submit","finish"],"sourceRoot":""}