{"version":3,"file":"main.bundle.js","mappings":"mBAIA,IAAIA,EAAgB,K,UAEa,YAC7B,MAAMC,ECPiB,MACvB,IAAIC,EAAS,+CAUb,OATSC,UAAUC,MACZF,EAAS,4hBAQTA,GDJUG,GACjB,GAAGJ,EAASK,SAAS,sBAEjB,MADAC,QAAQC,IAAIP,GACP,qBAET,MAAMQ,EAASC,SAASC,cAAc,kBAEhCC,QAAgBT,UAAUC,IAAIS,iBAC9BC,QAAeF,MAAAA,OAAO,EAAPA,EAASG,gBAExBC,EAAUP,EAAOQ,WAAW,UAE5BC,EAAmBC,OAAOD,kBAAoB,EAC9CE,EAAmB,CACrBX,EAAOY,YAAcH,EACrBT,EAAOa,aAAeJ,GAEpBK,EAAqBP,EAAQQ,mBAAmBZ,GAGtDI,EAAQS,UAAU,CACdX,OAAAA,EACAY,OAAQH,EACRI,KAAMP,IAER,MAAMQ,EE/BO,m8BF+BPA,EEPS,qKFQTC,EAAWf,EAAOgB,qBAAqB,CAC3CC,OAAQ,CACNC,OAAQlB,EAAOmB,mBAAmB,CAChCC,KAAMN,IAERO,WAAY,QAEdC,SAAU,CACRJ,OAAQlB,EAAOmB,mBAAmB,CAChCC,KAAMN,IAERO,WAAY,OACZE,QAAS,CACP,CACEX,OAAQH,KAIde,UAAW,CACTC,SAAU,mBAGC,OAAZvC,GAAkBwC,qBAAqBxC,GA0B1CA,EAAYyC,uBAzBZ,SAASC,IAGP,MAAMC,EAAiB7B,EAAO8B,uBAGxBC,EAAgD,CACpDC,iBAAkB,CAChB,CACEC,KALc/B,EAAQgC,oBAAoBC,aAM1CC,UAAW,CAAEC,EAAG,GAAKC,EAAG,GAAKC,EAAG,GAAKC,EAAG,GACxCC,QAAS,WAKTC,EAAcb,EAAec,gBAAgBZ,GACnDW,EAAYE,YAAY7B,GACxB2B,EAAYG,KAAK,EAAG,EAAG,EAAG,GAC1BH,EAAYI,UAEZ9C,EAAO+C,MAAMC,OAAO,CAACnB,EAAeoB,WACpC/D,EAAayC,sBAAsBC,O,YAxEV,K,kPAAA,E","sources":["webpack://webgpu01/./src/main.ts","webpack://webgpu01/./src/helper.ts","webpack://webgpu01/./src/shader.ts"],"sourcesContent":["import $ from 'jquery';\nimport { CheckWebGPU } from './helper';\nimport { Shaders } from './shader';\n\nlet requestId:any = null\n\nconst createTriangle = async ()=>{\n    const checkgpu = CheckWebGPU();\n    if(checkgpu.includes('not support WebGPU')){\n        console.log(checkgpu)\n        throw('not support WebGPU')\n    }\n    const canvas = document.querySelector('#canvas-webgpu') as HTMLCanvasElement;\n    \n    const adapter = await navigator.gpu.requestAdapter() as GPUAdapter\n    const device = await adapter?.requestDevice() as GPUDevice\n    \n    const context = canvas.getContext('webgpu')as unknown  as GPUCanvasContext\n  \n    const devicePixelRatio = window.devicePixelRatio || 1;\n    const presentationSize = [\n        canvas.clientWidth * devicePixelRatio,\n        canvas.clientHeight * devicePixelRatio,\n    ];\n    const presentationFormat = context.getPreferredFormat(adapter);\n\n    \n    context.configure({\n        device,\n        format: presentationFormat,\n        size: presentationSize,\n      });\n      const shader = Shaders();\n      const pipeline = device.createRenderPipeline({\n        vertex: {\n          module: device.createShaderModule({\n            code: shader.vertex,\n          }),\n          entryPoint: 'main',\n        },\n        fragment: {\n          module: device.createShaderModule({\n            code: shader.fragment,\n          }),\n          entryPoint: 'main',\n          targets: [\n            {\n              format: presentationFormat,\n            },\n          ],\n        },\n        primitive: {\n          topology: 'triangle-list',\n        },\n      });\n      if(requestId!==null) cancelAnimationFrame(requestId)\n      function frame() {\n        // Sample is no longer the active page.\n    \n        const commandEncoder = device.createCommandEncoder();\n        const textureView = context.getCurrentTexture().createView();\n    \n        const renderPassDescriptor: GPURenderPassDescriptor = {\n          colorAttachments: [\n            {\n              view: textureView,\n              loadValue: { r: 0.5, g: 0.5, b: 0.8, a: 1.0 },\n              storeOp: 'store',\n            },\n          ],\n        };\n    \n        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n        passEncoder.setPipeline(pipeline);\n        passEncoder.draw(3, 1, 0, 0);\n        passEncoder.endPass();\n    \n        device.queue.submit([commandEncoder.finish()]);\n        requestId =  requestAnimationFrame(frame);\n      }\n    \n      requestId = requestAnimationFrame(frame);\n    \n}\n\n\ncreateTriangle();\n","export const CheckWebGPU = () => {\n    let result = 'Great, your current browser supports WebGPU!';\n        if (!navigator.gpu) {\n           result = `Your current browser does not support WebGPU! Make sure you are on a system \n                     with WebGPU enabled. Currently, SPIR-WebGPU is only supported in  \n                     <a href=\"https://www.google.com/chrome/canary/\">Chrome canary</a>\n                     with the flag \"enable-unsafe-webgpu\" enabled. See the \n                     <a href=\"https://github.com/gpuweb/gpuweb/wiki/Implementation-Status\"> \n                     Implementation Status</a> page for more details.                   \n                    `;\n        } \n    return result;\n}","export const Shaders = ()=>{\n    const vertex = `\n            struct VertexOutput {\n                @builtin(position) Position : vec4<f32>;\n                @location(1) vColor: vec4<f32>;\n            };\n            @stage(vertex)\n            fn main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n                var output : VertexOutput;\n                var pos:array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                    vec2<f32>(0.0, 0.5),\n                    vec2<f32>(-0.5, -0.5),\n                    vec2<f32>(0.5, -0.5));\n\n                var color:array<vec3<f32>, 3> = array<vec3<f32>, 3>(\n                        vec3<f32>(1.0, 0.0, 0.0),\n                        vec3<f32>(0.0, 1.0, 0.0),\n                        vec3<f32>(0.0, 0.0, 1.0));     \n                    \n                 output.vColor = vec4<f32>(color[VertexIndex], 1.0);\n                 output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n                return output;\n            }\n    `;\n\n    const fragment = `\n            @stage(fragment)\n            fn main(@location(1) vColor: vec4<f32>) -> @location(0) vec4<f32>{\n               return vColor;\n            }\n    `;\n    return {vertex, fragment}\n}"],"names":["requestId","checkgpu","result","navigator","gpu","CheckWebGPU","includes","console","log","canvas","document","querySelector","adapter","requestAdapter","device","requestDevice","context","getContext","devicePixelRatio","window","presentationSize","clientWidth","clientHeight","presentationFormat","getPreferredFormat","configure","format","size","shader","pipeline","createRenderPipeline","vertex","module","createShaderModule","code","entryPoint","fragment","targets","primitive","topology","cancelAnimationFrame","requestAnimationFrame","frame","commandEncoder","createCommandEncoder","renderPassDescriptor","colorAttachments","view","getCurrentTexture","createView","loadValue","r","g","b","a","storeOp","passEncoder","beginRenderPass","setPipeline","draw","endPass","queue","submit","finish"],"sourceRoot":""}