(()=>{"use strict";const e=(e,t,n=GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST)=>{const o=e.createBuffer({size:t.byteLength,usage:n,mappedAtCreation:!0});return new Float32Array(o.getMappedRange()).set(t),o.unmap(),o},t=()=>{return e=void 0,o=void 0,a=function*(){const e=n();if(e.includes("not support WebGPU"))throw console.log(e),"not support WebGPU";const o=document.querySelector("#canvas-webgpu"),r=yield navigator.gpu.requestAdapter();let a=yield null==r?void 0:r.requestDevice();a.lost.then((e=>{console.error(`WebGPU device was lost: ${e.message}`),a=null,"destroyed"!=e.reason&&t()}));const i=o.getContext("webgpu"),u=window.devicePixelRatio||1,s=[o.clientWidth*u,o.clientHeight*u],c=i.getPreferredFormat(r);return i.configure({device:a,format:c,size:s}),{device:a,canvas:o,context:i,presentationFormat:c}},new((r=void 0)||(r=Promise))((function(t,n){function i(e){try{s(a.next(e))}catch(e){n(e)}}function u(e){try{s(a.throw(e))}catch(e){n(e)}}function s(e){var n;e.done?t(e.value):(n=e.value,n instanceof r?n:new r((function(e){e(n)}))).then(i,u)}s((a=a.apply(e,o||[])).next())}));var e,o,r,a},n=()=>{let e="Great, your current browser supports WebGPU!";return navigator.gpu||(e='Your current browser does not support WebGPU! Make sure you are on a system \n                     with WebGPU enabled. Currently, SPIR-WebGPU is only supported in  \n                     <a href="https://www.google.com/chrome/canary/">Chrome canary</a>\n                     with the flag "enable-unsafe-webgpu" enabled. See the \n                     <a href="https://github.com/gpuweb/gpuweb/wiki/Implementation-Status"> \n                     Implementation Status</a> page for more details.                   \n                    '),e};let o=null;var r,a;a=function*(){const{device:n,context:r,presentationFormat:a}=yield t(),i=new Float32Array([-.5,-.5,.5,-.5,-.5,.5,-.5,.5,.5,-.5,.5,.5]),u=new Float32Array([1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,0,1]),s=e(n,i),c=e(n,u),l="\n            struct VertexOutput {\n                @builtin(position) Position : vec4<f32>;\n                @location(1) vColor: vec4<f32>;\n            };\n\n            @stage(vertex)\n            fn main(@location(0) pos:vec4<f32>,\n                    @location(1) color:vec4<f32>) -> VertexOutput{   \n                var output : VertexOutput;      \n                output.Position = pos;\n                output.vColor = color;\n                return output;\n            }\n    ",f="\n            @stage(fragment)\n            fn main(@location(1) vColor: vec4<f32>) -> @location(0) vec4<f32>{\n                return vColor;\n            }\n    ",d=n.createRenderPipeline({vertex:{module:n.createShaderModule({code:l}),entryPoint:"main",buffers:[{arrayStride:8,attributes:[{shaderLocation:0,format:"float32x2",offset:0}]},{arrayStride:12,attributes:[{shaderLocation:1,format:"float32x3",offset:0}]}]},fragment:{module:n.createShaderModule({code:f}),entryPoint:"main",targets:[{format:a}]},primitive:{topology:"triangle-list"}});o=requestAnimationFrame((function(){const e=n.createCommandEncoder(),t={colorAttachments:[{view:r.getCurrentTexture().createView(),loadValue:{r:.5,g:.5,b:.8,a:1},storeOp:"store"}]},o=e.beginRenderPass(t);o.setPipeline(d),o.setVertexBuffer(0,s),o.setVertexBuffer(1,c),o.draw(6),o.endPass(),n.queue.submit([e.finish()])}))},new((r=void 0)||(r=Promise))((function(e,t){function n(e){try{i(a.next(e))}catch(e){t(e)}}function o(e){try{i(a.throw(e))}catch(e){t(e)}}function i(t){var a;t.done?e(t.value):(a=t.value,a instanceof r?a:new r((function(e){e(a)}))).then(n,o)}i((a=a.apply(void 0,[])).next())}))})();
//# sourceMappingURL=main.bundle.js.map