(()=>{"use strict";const e=()=>{return n=void 0,o=void 0,a=function*(){const n=t();if(n.includes("not support WebGPU"))throw console.log(n),"not support WebGPU";const o=document.querySelector("#canvas-webgpu"),r=yield navigator.gpu.requestAdapter();let a=yield null==r?void 0:r.requestDevice();a.lost.then((t=>{console.error(`WebGPU device was lost: ${t.message}`),a=null,"destroyed"!=t.reason&&e()}));const i=o.getContext("webgpu"),u=window.devicePixelRatio||1,c=[o.clientWidth*u,o.clientHeight*u],s=i.getPreferredFormat(r);return i.configure({device:a,format:s,size:c}),{device:a,canvas:o,context:i,presentationFormat:s}},new((r=void 0)||(r=Promise))((function(e,t){function i(e){try{c(a.next(e))}catch(e){t(e)}}function u(e){try{c(a.throw(e))}catch(e){t(e)}}function c(t){var n;t.done?e(t.value):(n=t.value,n instanceof r?n:new r((function(e){e(n)}))).then(i,u)}c((a=a.apply(n,o||[])).next())}));var n,o,r,a},t=()=>{let e="Great, your current browser supports WebGPU!";return navigator.gpu||(e='Your current browser does not support WebGPU! Make sure you are on a system \n                     with WebGPU enabled. Currently, SPIR-WebGPU is only supported in  \n                     <a href="https://www.google.com/chrome/canary/">Chrome canary</a>\n                     with the flag "enable-unsafe-webgpu" enabled. See the \n                     <a href="https://github.com/gpuweb/gpuweb/wiki/Implementation-Status"> \n                     Implementation Status</a> page for more details.                   \n                    '),e};let n=null;var o,r;r=function*(){const{device:t,context:o,presentationFormat:r}=yield e(),a=new Float32Array([-.5,-.5,1,0,0,.5,-.5,0,1,0,-.5,.5,1,1,0,-.5,.5,1,1,0,.5,-.5,0,1,0,.5,.5,0,0,1]),i=((e,t,n=GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST)=>{const o=e.createBuffer({size:t.byteLength,usage:n,mappedAtCreation:!0});return new Float32Array(o.getMappedRange()).set(t),o.unmap(),o})(t,a),u="\n            struct VertexOutput {\n                @builtin(position) Position : vec4<f32>;\n                @location(1) vColor: vec4<f32>;\n            };\n\n            @stage(vertex)\n            fn main(@location(0) pos:vec4<f32>,\n                    @location(1) color:vec4<f32>) -> VertexOutput{   \n                var output : VertexOutput;      \n                output.Position = pos;\n                output.vColor = color;\n                return output;\n            }\n    ",c="\n            @stage(fragment)\n            fn main(@location(1) vColor: vec4<f32>) -> @location(0) vec4<f32>{\n                return vColor;\n            }\n    ",s=t.createRenderPipeline({vertex:{module:t.createShaderModule({code:u}),entryPoint:"main",buffers:[{arrayStride:20,attributes:[{shaderLocation:0,format:"float32x2",offset:0},{shaderLocation:1,format:"float32x3",offset:8}]}]},fragment:{module:t.createShaderModule({code:c}),entryPoint:"main",targets:[{format:r}]},primitive:{topology:"triangle-list"}});n=requestAnimationFrame((function(){const e=t.createCommandEncoder(),n={colorAttachments:[{view:o.getCurrentTexture().createView(),loadValue:{r:.5,g:.5,b:.8,a:1},storeOp:"store"}]},r=e.beginRenderPass(n);r.setPipeline(s),r.setVertexBuffer(0,i),r.draw(6),r.endPass(),t.queue.submit([e.finish()])}))},new((o=void 0)||(o=Promise))((function(e,t){function n(e){try{i(r.next(e))}catch(e){t(e)}}function a(e){try{i(r.throw(e))}catch(e){t(e)}}function i(t){var r;t.done?e(t.value):(r=t.value,r instanceof o?r:new o((function(e){e(r)}))).then(n,a)}i((r=r.apply(void 0,[])).next())}))})();
//# sourceMappingURL=main.bundle.js.map