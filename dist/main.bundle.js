(()=>{"use strict";let e=null;var t,n;n=function*(){const t=(()=>{let e="Great, your current browser supports WebGPU!";return navigator.gpu||(e='Your current browser does not support WebGPU! Make sure you are on a system \n                     with WebGPU enabled. Currently, SPIR-WebGPU is only supported in  \n                     <a href="https://www.google.com/chrome/canary/">Chrome canary</a>\n                     with the flag "enable-unsafe-webgpu" enabled. See the \n                     <a href="https://github.com/gpuweb/gpuweb/wiki/Implementation-Status"> \n                     Implementation Status</a> page for more details.                   \n                    '),e})();if(t.includes("not support WebGPU"))throw console.log(t),"not support WebGPU";const n=document.querySelector("#canvas-webgpu"),r=yield navigator.gpu.requestAdapter(),o=yield null==r?void 0:r.requestDevice(),a=n.getContext("webgpu"),i=window.devicePixelRatio||1,u=[n.clientWidth*i,n.clientHeight*i],c=a.getPreferredFormat(r);a.configure({device:o,format:c,size:u});const s="\n            struct VertexOutput {\n                @builtin(position) Position : vec4<f32>;\n                @location(1) vColor: vec4<f32>;\n            };\n            @stage(vertex)\n            fn main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n                var output : VertexOutput;\n                var pos:array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                    vec2<f32>(0.0, 0.5),\n                    vec2<f32>(-0.5, -0.5),\n                    vec2<f32>(0.5, -0.5));\n\n                var color:array<vec3<f32>, 3> = array<vec3<f32>, 3>(\n                        vec3<f32>(1.0, 0.0, 0.0),\n                        vec3<f32>(0.0, 1.0, 0.0),\n                        vec3<f32>(0.0, 0.0, 1.0));     \n                    \n                 output.vColor = vec4<f32>(color[VertexIndex], 1.0);\n                 output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n                return output;\n            }\n    ",l="\n            @stage(fragment)\n            fn main(@location(1) vColor: vec4<f32>) -> @location(0) vec4<f32>{\n               return vColor;\n            }\n    ",v=o.createRenderPipeline({vertex:{module:o.createShaderModule({code:s}),entryPoint:"main"},fragment:{module:o.createShaderModule({code:l}),entryPoint:"main",targets:[{format:c}]},primitive:{topology:"triangle-list"}});null!==e&&cancelAnimationFrame(e),e=requestAnimationFrame((function t(){const n=o.createCommandEncoder(),r={colorAttachments:[{view:a.getCurrentTexture().createView(),loadValue:{r:.5,g:.5,b:.8,a:1},storeOp:"store"}]},i=n.beginRenderPass(r);i.setPipeline(v),i.draw(3,1,0,0),i.endPass(),o.queue.submit([n.finish()]),e=requestAnimationFrame(t)}))},new((t=void 0)||(t=Promise))((function(e,r){function o(e){try{i(n.next(e))}catch(e){r(e)}}function a(e){try{i(n.throw(e))}catch(e){r(e)}}function i(n){var r;n.done?e(n.value):(r=n.value,r instanceof t?r:new t((function(e){e(r)}))).then(o,a)}i((n=n.apply(void 0,[])).next())}))})();
//# sourceMappingURL=main.bundle.js.map